\documentclass{article}\usepackage{amsmath,amssymb,amsthm,tikz,tkz-graph,color,chngpage,soul,hyperref,csquotes,graphicx,floatrow, listings,polynom}\newcommand*{\QEDB}{\hfill\ensuremath{\square}}\newtheorem*{prop}{Proposition}\renewcommand{\theenumi}{\alph{enumi}}\usepackage[shortlabels]{enumitem}\usepackage[nobreak=true]{mdframed}\usetikzlibrary{matrix,calc}\MakeOuterQuote{"}\usepackage[margin=0.75in]{geometry} \newtheorem{theorem}{Theorem}\newcommand{\Z}{\mathbb Z}\newcommand{\R}{\mathbb R}\newcommand{\Q}{\mathbb Q}\newcommand{\N}{\mathbb N}\newcommand{\x}[1]{\textrm{ #1 }}\newcommand{\pr}{\textrm{Pr}}
\newcommand{\dincludegraphics}{\includegraphics[width=0.5\textwidth]}
\newcommand{\tincludegraphics}{\includegraphics[width=0.33\textwidth]}
\newcommand{\sumlim}[3]{\sum\limits_{#1}^{#2}#3}
\newcommand{\eq}[1]{\begin{equation}#1\end{equation}}

\title{CS70 - Midterm 2 Notes}
\author{Name: Felix Su$\quad$SID: 25794773}
\date{Spring 2016$\quad$GSI: Gerald Zhang}
\begin{document}
\maketitle

%%%% Topic %%%%
\subsection*{Review}
%%%% Notes %%%%
\begin{itemize}
    \item $e$ and $(p − 1)(q − 1)$ are \textbf{Relatively Prime}: $gcd(e,(p − 1)(q − 1)) = 1$
    \item $d$ is the \textbf{Multiplicative Inverse} of $e \bmod (p-1)(q-1)$: $ed = 1 \bmod (p-1)(q-1)$
    \item If $p$ is prime, \textbf{Fermat's Little Thm}: $x^{p-1} = 1 \bmod p$
\end{itemize}

Graphs

Error-correcting Codes
List Decoding

Independence
Bonferroni Inequalities
Sample Space
Union Bound
Unlikely Probability
Union
Intersection
Collisions
Probability Space
Approximate Limit

Counting
Countability

% 	Finite Fields
% 	Degree
% 	Divides
% Berlekamp-Welsh

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Topic %%%%
\subsection*{Polynomials}
%%%% Notes %%%%
\begin{mdframed}
\textbf{Properties and Theorems}
\begin{itemize}
    \item \textbf{Root Fact}: A non-zero polynomial of degree $d$ has at most $d$ roots
    \item \textbf{Fact}: Any $d+1$ points specifies a distinct degree $d$ polynomial 
    \item \textbf{Modular Fact}: Any $d+1$ points specifies a distinct degree $d$ polynomial in mod $p$ space when $p$ is prime
    \item \textbf{Uniqueness Fact}: At most one degree $d$ polynomial hits $d+1$ points\\
\end{itemize}
\end{mdframed}
%%%% Mod Space %%%%
\textbf{Mod Space}
\begin{itemize}
    \item Polynomials only map to $f(x)$ at integer values of $x$
    \item $f(x)$ is contained in the mod space
    \item Use delta functions to create meaningful polynomials in mod space
\end{itemize}
%%%% Shamir %%%%
\textbf{Shamir's $k$ out of $n$ scheme:}
\begin{itemize}
    \item Secret $s \in \{0, ..., p-1\}$
    \item Set $a_0 = s$, randomly assign $a_1, ..., a_{k-1}$
    \item Let $P(x) = a_{k-1}x^{k-1} + a_{k-2}x^{k-2} + ... + a0$ with $P(0) = a_0 = s$
    \item Share $(i, P(i) \bmod p)$ with $i$-th person
    \item $k$ shares gives secret (degree $= d = k-1$, Modular fact, $d+1 = k$ shares gives the polynomial which reveals $P(0) = s$
    \item Solve system of linear equations to get $a_0$
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Lagrange Interpolation %%%%
\subsection*{Lagrange Interpolation}
\textbf{Delta Function}
\eq{
\Delta_i(x) =
\begin{cases}
1, & x =x_i \\
0, & x =x_j \text{ for } j\ne i \\
\text{doesn't matter}, & x = \text{anything else}
\end{cases}
}
\begin{itemize}
\item 1 at one point (x-value), 0 everywhere else
\item valid for a set of x values $x_1, ..., x_{d+1}$
\item $y_i\Delta_i(x) = y_i$ because $\Delta_i(x)$ is 1 at $x_i$ and 0 everywhere else
	\begin{itemize}[label=$\star$]
	\item $P(x) = y_1\Delta_1(x) + y_2\Delta_2(x) + ... + y_{d+1}\Delta_{d+1}(x)$ because at $x_i$ you only get $y_i$ ($\Delta{x_i}$ is 0 at anything except $x_i$)
	\end{itemize}
\begin{mdframed}
\textbf{Formation of Delta Function}:\\
Given points: $(x_1, y_1); (x_2, y_2); ... (x_{d+1}, y_{d+1})$\\\\
\eq{\Delta_i(x) = \frac{\prod_{j\ne i}(x-x_j)}{\prod_{j\ne i}(x_i-x_j)}}
\textbf{Resulting Polynomial}
\eq{P(x)=y_1\Delta_1(x)+y_2\Delta_2(x)+\cdots+y_{d+1}\Delta_{d+1}(x)}
\end{mdframed}
\end{itemize}
%%%%Secret Sharing%%%%
\subsection*{Secret Sharing}
\textbf{Minimality}
\begin{itemize}
\item Use mod $p$ space where $p$ is prime
\item $p > n$ where n is the amount of shares you want to hand out
\item $p > 2^b$ where $b$ is the number of bits you want in your secret
\item Uses \textbf{Theorem}(There is always a prime between $n$ and $2n$). This strategy chooses a $p$ that is within 1 bit of secret size (minimality).
\end{itemize}
\textbf{Runtime}
\begin{itemize}
\item Polynomial in terms of $k$, $n$, and $\log{p}$
\item Evaluate $k-1$ degree polynomials $n$ times as a system of linear equations, using $\log{p}$-bit numbers
\item Reconstruct secret by solving system of $k$ equations using $\log{p}$-bit arithmetic.
\end{itemize}
\textbf{Counting}
\begin{itemize}
\item $m^{d+1}$: $d+1$ coefficients must be $\in \{0, ..., m-1\}$
\item $m^{d+1}$: $d+1$ points with $y$-values that must be $\in \{0, ..., m-1\}$
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection*{Erasure Codes}
\textbf{Solution}
\begin{itemize}
\item $n$ packet message, loses $k$ packets in channel
\item must send $n+k$ packets
\item Use $n$ point values to construct an $n-1$ degree polynomial
\end{itemize}
\begin{mdframed}
\textbf{Erasure Coding Scheme:}
\begin{enumerate}[1.]
\item $n$ packet message: $m_0, m_1, ... , m_{n-1}$
\item Choose prime $p \approx 2^b$ for mod space where each packet has $b$ bits
\item $p > n+k$
\item $P(x) = m_{n-1}x^{n-1} + ... + m_0 \pmod{p}$
\item Send, $P(1), ..., P(n+k)$
\end{enumerate}
Any $n$ of the $n+k$ packets gives polynomial and the entire message (all coefficients or $y$-values)
\end{mdframed}
\begin{mdframed}
\textbf{Erasure Coding Example:}\\
\textbf{Sending}\\
Send message 1, 4, 4 (3 packets, 2 bits)\\
Make $P(x)$: $P(1) = 1, P(2) = 4, P(3) = 4$\\
Try $\bmod 5$ because 5 is the closest prime to $2^b = 4$, but only gives 5 possible shares, so work $\bmod 7$\\
Use Lagrange Interpolation\\
$P(x) = 2x^2 + 4x + 2 \bmod 7$\\
Send $(0, P(0))(1,P(1))...(6,P(7))$: 6 points\\
\textbf{Receieving}\\
Retrieve $P(x)$ using Lagrange or system of linear equations\\
Need to know which $x$-value the correct packets correspond to\\
\end{mdframed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Topic %%%%
\subsection*{Error Correction}
%%%% Notes %%%%
\begin{itemize}
\item Need to recover information sent AND which packets are corrupted
\item Send $n+2k$ packets because if $k$ errors exist, multiple original messages are possible if $< n+2k$ packets sent.
\end{itemize}
\begin{mdframed}
\textbf{Reed-Solomon Code:}
\begin{enumerate}[1.]
\item Encoding polynomial $P(x)$ of degree n-1
    \begin{itemize}
    \item $P(1) = m_1,..., P(n) = m_n$
    \item Can encode with packets as coefficients (check HW6)
    \end{itemize}
\item Use \textbf{Lagrange Interpolation} to get $P(x)$
\item Send $(P1), ..., P(n+2k)$
\item After noisy channel, receive $R(1), ..., R(n+2k)$
\item $P(i) = R(i)$ for at least $n+k$ points $i$; $P(i) \ne R(i)$ for $k$ points
\item Do not know where errors occurred
\item $P(x) =$ unique degree $n-1$ polynomial
\end{enumerate}
\textbf{Error Locator Polynomial:} $\boldsymbol{E(x)=(x-e_1)(x-e_2)\cdots(x-e_k)}$
\begin{itemize}
\item Errors at points $e_1, ... e_k$; E(i) = 0 iff $e_j = i$ for some $j$; $E(x)$ has degree $k$
\item Idea: Multiply equation $i$ by $E(x) = (x - i)$ iff $P(i) \ne R(i)$, but this creates $n+2k$ \textbf{non-linear} equations with $n_k$ unknowns.
\item \textbf{Solution:} Let $Q(x) = E(x)P(x) = a_{n+k-1}x^{n+k-1} + \cdots + a_0$
    \begin{itemize}
    \item Now you have $n+2k$ linear equations $Q(i) = R(i)E(i)$
    \item \textbf{Find $E(x)$ and $Q(x)$}
        \begin{itemize}
            \item $E(x) = x^k+b_{k-1}x^{k-1}\vdots b_0$ w/ $k$ unknown coefficients
            \item $Q(x) = a_{n+k-1}x^{n+k-1} + \cdots + a_0$ w/ $n+k$ unknown coefficients
            \item Solve for coefficients of $Q(x)$ and $E(x)$; Total Unknowns: $n+2k$
        \end{itemize}
    \item $\boldsymbol{P(x) = Q(x)/E(x)}$
    \end{itemize}
\end{itemize}
\end{mdframed}
\begin{mdframed}

\textbf{Brute force: BAD}
\begin{itemize}
\item Remove every possible combination of $k$ received packets one at a time and form a degree $n+k-1$ polynomial with remaining $n+k$ points. First consistent solution gives the corrupted packet.
\item Runtime: $(n/k)^k$: exponential in $k$ with $\binom{n+2k}{k}$ possibilities
\end{itemize}
\end{mdframed}

\begin{mdframed}
\textbf{RS Code Example:}\\
\textbf{Problem:}
\begin{itemize}
\item Message 3,0,6 : tolerate $k = 1$ errors (send $n+2k = 5$ packets)
\item Lagrange Encoding $P(x) = x^2 + x + 1 \pmod{7}$
\item Send: $P(1) = 3, P(2) = 0, P(3) = 6, P(4) = 0, P(5) = 3$
\item Receive: $R(1) = 3, R(2) = 1, R(3) = 6, R(4) = 0, R(5) = 3$
\end{itemize}
\textbf{Solution: Berklekamp-Welsh Algorithm}
\begin{itemize}
\item $Q(x) = E(x)P(x) = a_3x^3+a_2x^2+a_1x+a_0$
\item $E(x) = x-b_0$
\item $Q(i) = R(i)E(i)$
\begin{align*}
a_3+a_2+a_1+a_0 & \equiv 3(1-b_0) \pmod{7} \\
a_3+4a_2+2a_1+a_0 & \equiv 1(2-b_0) \pmod{7} \\
6a_3+2a_2+3a_1+a_0 & \equiv 6(3-b_0) \pmod{7} \\
a_3+2a_2+4a_1+a_0 & \equiv 0(4-b_0) \pmod{7} \\
6a_3+4a_2+5a_1+a_0 & \equiv 3(1-b_0) \pmod{7} 
\end{align*}
\item Gaussian Elimnation: $a_3=1, a_2=6, a_1=6, a_0=5$; $b_0=2$
\item $Q(x) = x^3+6x^2+6x+5$
\item $E(x)=x-2$
\item Polynomial Long Division: $P(x) = Q(x)/E(x) = x^2+x+1 \pmod{7}$\\
\polylongdiv{x^3+6x^2+6x+5}{x-2}
\item\textbf{Message = 3,0,6}
\item RS Code: $P(x) = x^2 + x + 1 \pmod{7}$ where $P(1) = 3, P(2) = 0, P(3) = 6$
\end{itemize}
\end{mdframed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Topic %%%%
\subsection*{RSA Encryption}
%%%% Notes %%%%
\begin{itemize}
    \item Public Key Encryption 2 keys:
    \begin{itemize}
        \item Public key: $(N, e)$ known to everyone, Encryption Function: $E(x) \equiv x^e \bmod N$
        \item Private key: $d$ only known to Bob, Decrypting Function: $D(x) \equiv x^d \bmod N$
    \end{itemize}
    \item Bijection that can only be inverted with private key
    \item Sender applies the encryption function $E$ to $x$ to obtain a ciphertext $E(x)$, which she then sends to receiver ($E : \{0,...,N-1\} \mapsto \{0,\cdots,N-1\}$) ($x \in \{1,\cdots,N-1\}$)
    \item Receiver applies decryption function $D$ to recover x.
    \item $D(E(x)) = x \bmod N$ for all $x \in \{0,1,\cdots,N-1\}$
    \begin{itemize}
        \item $(x^e)^d = x \bmod N$ for every $x \in \{0,1,...,N-1\}$
    \end{itemize}
    \item Key creator has to find prime numbers $p$ and $q$, each having many (say, 512) bits.
    \item Sender has to compute $y=E(x)=x^e \bmod N$, and Receiver has to compute $D(y)= y^d \bmod N$
\end{itemize}
\begin{mdframed}
\textbf{Given}
\begin{itemize}
    \item $N = pq$ for two large primes $p$ and $q$, usually a 512-bit number
    \item $e$ is relatively prime to $(p-1)(q-1)$
    \item $d$ = multiplicative inverse of $e \bmod (p-1)(q-1)$
\end{itemize}
\eq{E(x) \equiv x^e \bmod N}
\eq{D(x) \equiv x^d \bmod N}
\end{mdframed}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Topic %%%%
\subsection*{Counting}
%%%% Notes %%%%
\textbf{Combinations and Permutations}
\begin{itemize}
    \item Order
    \begin{itemize}
        \item Matters:
        \item Doesn't Matter:
    \end{itemize}
    \item Replacement
    \begin{itemize}
        \item With:
        \item Without:
    \end{itemize}
\end{itemize}
\begin{mdframed}
\textbf{Highlight:}
\end{mdframed}

%%%% Topic %%%%
\subsection*{Halt Program}
%%%% Notes %%%%
\textbf{Reduction}
\begin{itemize}
    \item Disprove program's existance by reducing to "I can use this program to solve HALT"
\end{itemize}
\begin{mdframed}
\textbf{Highlight:}
\end{mdframed}
%%%%%%%%%%%%%%$
\textbf{Diagonalization}
\begin{itemize}
    \item Listing
\end{itemize}
\begin{mdframed}
\textbf{Highlight:}
\end{mdframed}
%%%%%%%%%%%%%%$
\textbf{Turing Program}
\begin{itemize}
    \item 
\end{itemize}
\begin{mdframed}
\textbf{Highlight:}
\end{mdframed}

%%%% Topic %%%%
\subsection*{Probability}
%%%% Notes %%%%
\textbf{Bayes' Rule}
\begin{itemize}
    \item Content
\end{itemize}
\begin{mdframed}
\eq{\pr[A|B]=\frac{\pr[A]\pr[B|A]}{\pr[B]}}
\textbf{Uses}
\begin{itemize}
    \item Find probability of $A$ given $B$
    \item Use Law of Total Probability to find $\pr[A]$ and $\pr[B]$ if prior probabilities exist
\end{itemize}
\end{mdframed}
%%%%%%%%%%%%%%%
\textbf{Product Rule}
\begin{itemize}
    \item Content
\end{itemize}
\begin{mdframed}
\eq{\pr[A_1\cap\cdots\cap A_m]=\pr[A_1]\pr[A_2|A_1]\cdots\pr[A_m|A_1\cap\cdots\cap A_{m-1}]}
\end{mdframed}
%%%%%%%%%%%%%%%
\textbf{Law of Total Probabilities}
\begin{itemize}
    \item Probability of event $B$ is equivalent to the sum of the product of each of $B$'s prior probabilities and the chance of $B$ occuring given that prior probability.
\end{itemize}
\begin{mdframed}
\eq{\pr[B]=\pr[A_1]\pr[B|A_1]+\cdots+\pr[A_n]\pr[B|A_n]}
\textbf{Uses}
\begin{itemize}
    \item Find denominator for Bayes' Rule problem
    \item Get probability of any event that has prior probabilities
\end{itemize}
\end{mdframed}
%%%%%%%%%%%%%%%
\textbf{Bonferroni's Inequalities}
\begin{itemize}
    \item Content
\end{itemize}
\begin{mdframed}
\eq{\pr[A \cap B] > \pr[A] + \pr[B] - 1}
\eq{\pr[A_1 \cap\cdots\cap A_n] > \pr[A_1] + . . . + \pr[A_n] - (n - 1)}
\textbf{Uses}
\begin{itemize}
    \item Stuff
\end{itemize}
\end{mdframed}

\end{document}